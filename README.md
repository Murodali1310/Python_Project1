# Игра "Змейка" на Pygame
Это моя версия игры "Змейка", созданной с использованием модуля Pygame. Она включает в себя пять уровней и разные виды бонусных фруктов. Графика создается путем импорта изображений и размещения их в соответствующих прямоугольниках с использованием Pygame.
## Установка
Чтобы установить модуль Pygame:

Скачайте установщик Python 3 с официального веб-сайта и установите его, если он не установлен.
Запустите следующую команду в терминале, чтобы установить библиотеку Pygame:
```
pip3 install pygame
```
## Запуск приложения
Скачайте исходный код из репозитория и запустите файл, как любой другой файл Python (.py).
Чтобы запустить игру, используйте следующую команду:
```
python3 main.py
```
## Змейка
Для инициализации змеи мы создадим класс Snake, который хранит следующие методы: 

1.*Конструктор*(с указанием цвета)

2.*draw_snake* -  отвечает за рисование змейки. 

3.*update_head_graphics* - определяет положение головы змейки.

4.*update_tail_graphics* - аналогичен предыдущему методу, но для хвоста змейки.

5.*move_snake* - перемещает змейку в текущем направлении, при столкновении добавляет еще одну координату в тело змейки.

6.*add_block* - проверяет, нужно ли добавить блок к змейке.

7.*play_crunch_sound* - используется для воспроизведения звука при столкновении.

## Фрукты
Класс Fruit достаточно прост, у нас есть три вида фруктов, которые мы размещаем в случайных координатах при каждом вызове:

1.*Конструктор* 

2.*draw_apple* - рисует обычное яблоко, которое приносит 1 очко.

3.*draw_orange* - рисует апельсин, приносящий 5 очков.

4.*draw_watermelon* - рисует арбуз, который обозначает победу.

5.*randomize* - размещает фрукт в случайной позиции с использованием модуля random.

## Газон
Этот класс хранит карты разных уровней.

1.*Constructor* -  содержит границы разных уровней (списки с координатами стен).

2.*draw_grass* - отвечает за рисование карт на экране.
## Main(Логика)
В этом классе мы определяем, что должна делать игра на каждой итерации игрового цикла.

1.*Constructor* - здесь мы инициализируем игровые элементы (змейку, фрукты, карту).

2.*update* - используется для обновления игровых элементов, таких как движение змейки и проверка на поражение.

3.*draw_elements* - этот метод используется для отрисовки всех элементов (карта, змейка, фрукты).

4.*check_colision* - проверяет, съела ли змейка фрукт, и случайно размещает фрукт, если он находится в неправильном месте (грани, тело змейки), а также увеличивает скорость змейки при столкновении.

5.*check_next_level* - проверяет, перешли ли мы на следующий уровень.

6.*pass_to_lvlv1*(2, 3, 4, 5) - в случае перехода на следующий уровень эти методы сбрасывают скорость и состояние змейки, а также отображают сообщение о переходе на следующий уровень.

7.*check_fail* - здесь мы проверяем, закончилась ли игра.

8.*update_record* - этот метод обновляет таблицу лидеров счета.

9.*game_overa_output* - в этом методе мы отображаем экран "Конец игры", воспроизводим соответствующие звуки и, в случае установки нового рекорда, отправляем сообщение о том, что у вас лучший результат. Здесь мы также сбрасываем счет, уровень и состояние змейки, и обновляем таблицу рекордов.

10.*draw_top_score* - этот метод используется для вывода таблицы лидеров.

11.*draw_score* - используется для отображения текущего счета в правом нижнем углу во время игры.


12.*game_won* - этот метод отвечает за отображение сообщения "Вы победили" и воспроизведение соответствующих звуков при завершении игры. Здесь также сбрасываются некоторые значения и состояние змейки.

13.*pause* - этот метод используется для приостановки игры, и в нем мы можем выводить любой текст, который мы хотим в окне паузы, перед тем как продолжить игру, нужно нажать клавишу "с", а чтобы выйти из игры, нужно нажать клавишу "q".

14.*check_game_won* - проверяет, выиграли ли мы игру.
 
## Другие детали

1.Наша змейка состоит из блоков, поэтому мы определяем наш экран как сетку, где cell_size - размер одной ячейки в пикселях, а cell_number - длина одной стороны нашего квадрата (экрана).

2. Мы инициализируем Pygame и определяем наш экран, а также устанавливаем начальную скорость змейки (snake_speed = 6).

3.Затем мы инициализируем экземпляр часов для отслеживания кадров в секунду.

4. Мы используем pygame.mixer для воспроизведения звуков, и мы используем pygame.mixer.pre_init(), чтобы воспроизводить звуки без задержки.
5. Мы отслеживаем время между нажатиями клавиш, чтобы избежать множественных нажатий клавиш одновременно.

## Игровой цикл
Здесь мы в основном работаем с событиями Pygame, чтобы обрабатывать команды пользователей. Существует несколько условий, которые учитывают разные случаи. Здесь мы также обновляем направление на каждой итерации, затем обновляем и отрисовываем основные игровые элементы.
